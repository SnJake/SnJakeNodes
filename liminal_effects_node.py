import torch
import math

class LiminalEffectsNode:
    """
    –ù–æ–¥–∞, —Å–æ–≤–º–µ—â–∞—é—â–∞—è:
      1) –ß/–± —à—É–º (noise_strength)
      2) –•—Ä–æ–º–∞—Ç–∏—á–µ—Å–∫—É—é –∞–±–µ—Ä—Ä–∞—Ü–∏—é (chromatic_shift)
      3) –í—ã—Ü–≤–µ—Ç–∞–Ω–∏–µ (fade_strength)
      4) –í–∏–Ω—å–µ—Ç–∫—É (vignette_strength)
      5) –¢—É–º–∞–Ω (fog_strength, fog_color)
      6) VHS-—ç—Ñ—Ñ–µ–∫—Ç (vhs_strength)
      7) –°–ª—É—á–∞–π–Ω—ã–µ –≥–ª–∏—Ç—á–∏ (glitch_strength)
    """

    CATEGORY = "üòé SnJake/Effects"
    FUNCTION = "apply_effects"
    RETURN_TYPES = ("IMAGE",)
    RETURN_NAMES = ("image_out",)

    @classmethod
    def INPUT_TYPES(cls):
        return {
            "required": {
                "image_in": ("IMAGE", {}),

                # —Å—Ç–∞—Ä—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã:
                "noise_strength": ("FLOAT", {
                    "default": 0.3, "min": 0.0, "max": 2.0, "step": 0.01,
                    "tooltip": "–°–∏–ª–∞ —á/–± —à—É–º–∞"
                }),
                "chromatic_shift": ("INT", {
                    "default": 2, "min": 0, "max": 20,
                    "tooltip": "–°–º–µ—â–µ–Ω–∏–µ –∫–∞–Ω–∞–ª–æ–≤ RGB (–ø–∏–∫—Å–µ–ª–∏)"
                }),
                "fade_strength": ("FLOAT", {
                    "default": 0.3, "min": 0.0, "max": 1.0, "step": 0.01,
                    "tooltip": "–í—ã—Ü–≤–µ—Ç–∞–Ω–∏–µ (0=–Ω–µ—Ç, 1=—Å–µ—Ä–æ–µ)"
                }),

                # –Ω–æ–≤—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã:
                "vignette_strength": ("FLOAT", {
                    "default": 0.0, "min": 0.0, "max": 1.0, "step": 0.01,
                    "tooltip": "–í–∏–Ω—å–µ—Ç–∫–∞: 0=–Ω–µ—Ç, 1=–º–∞–∫—Å."
                }),
                "fog_strength": ("FLOAT", {
                    "default": 0.0, "min": 0.0, "max": 1.0, "step": 0.01,
                    "tooltip": "–¢—É–º–∞–Ω: 0=–Ω–µ—Ç, 1=–ø–æ–ª–Ω–æ—Å—Ç—å—é –±–µ–ª–æ–µ"
                }),
                "fog_color": ("FLOAT", {
                    "default": 1.0, "min": 0.0, "max": 1.0, "step": 0.01,
                    "tooltip": "–¶–≤–µ—Ç —Ç—É–º–∞–Ω–∞ (—Å–µ—Ä—ã–π 0..1), 1=–±–µ–ª–æ–µ, 0=—á—ë—Ä–Ω–æ–µ"
                }),
                "vhs_strength": ("FLOAT", {
                    "default": 0.0, "min": 0.0, "max": 1.0, "step": 0.01,
                    "tooltip": "VHS-—ç—Ñ—Ñ–µ–∫—Ç (0=–≤—ã–∫–ª, 1=–º–∞–∫—Å)"
                }),
                "glitch_strength": ("FLOAT", {
                    "default": 0.0, "min": 0.0, "max": 1.0, "step": 0.01,
                    "tooltip": "–°–ª—É—á–∞–π–Ω—ã–µ –≥–ª–∏—Ç—á–∏ (0=–Ω–µ—Ç, 1=–º–∞–∫—Å)"
                }),

                "seed": ("INT", {
                    "default": 0, "min": 0, "max": 999999,
                    "tooltip": "–ó–µ—Ä–Ω–æ —à—É–º–∞ –∏ –≥–ª–∏—Ç—á–∞ (0 => –Ω–µ —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞—Ç—å)"
                }),
            }
        }

    def apply_effects(self,
                      image_in,
                      noise_strength,
                      chromatic_shift,
                      fade_strength,
                      vignette_strength,
                      fog_strength,
                      fog_color,
                      vhs_strength,
                      glitch_strength,
                      seed=0):
        """
        image_in:  [B, H, W, C]
        –í—Å–µ strength-–ø–∞—Ä–∞–º–µ—Ç—Ä—ã: float
        seed: int (–µ—Å–ª–∏ =0, seed –Ω–µ —Ñ–∏–∫—Å–∏—Ä—É–µ–º)
        """

        # –ü—Ä–∏–≤–æ–¥–∏–º [B,H,W,C] => [B,C,H,W]
        out = image_in.permute(0, 3, 1, 2).clone()

        # –ï—Å–ª–∏ –Ω–∞–¥–æ –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞—Ç—å –ø–æ–≤–µ–¥–µ–Ω–∏–µ —à—É–º–æ–≤/–≥–ª–∏—Ç—á–µ–π
        if seed != 0:
            torch.manual_seed(seed)

        # 1. –ß/–± —à—É–º
        if noise_strength > 0.0:
            out = self.add_grayscale_noise(out, noise_strength)

        # 2. –•—Ä–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –∞–±–µ—Ä—Ä–∞—Ü–∏—è
        if chromatic_shift > 0:
            out = self.chromatic_aberration(out, chromatic_shift)

        # 3. –í—ã—Ü–≤–µ—Ç–∞–Ω–∏–µ
        if fade_strength > 0.0:
            out = self.fade_image(out, fade_strength)

        # 4. –í–∏–Ω—å–µ—Ç–∫–∞
        if vignette_strength > 0.0:
            out = self.add_vignette(out, vignette_strength)

        # 5. –¢—É–º–∞–Ω
        if fog_strength > 0.0:
            out = self.add_fog(out, fog_strength, fog_color)

        # 6. VHS
        if vhs_strength > 0.0:
            out = self.add_vhs_effect(out, vhs_strength)

        # 7. –°–ª—É—á–∞–π–Ω—ã–µ –≥–ª–∏—Ç—á–∏
        if glitch_strength > 0.0:
            out = self.add_random_glitches(out, glitch_strength)

        # –ö–ª–∏–ø–∏–º –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –≤ [B,H,W,C]
        out = out.clamp(0.0, 1.0)
        out = out.permute(0, 2, 3, 1).contiguous()
        return (out,)

    # ------------------------------------------------------------------------
    # –ù–∏–∂–µ ‚Äî –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã

    def add_grayscale_noise(self, img, strength):
        """
        img: [B,C,H,W]
        –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —à—É–º (1 –∫–∞–Ω–∞–ª) –∏ –¥–æ–±–∞–≤–ª—è–µ–º –∫ img
        """
        B, C, H, W = img.shape
        noise = torch.randn(B, 1, H, W, device=img.device, dtype=img.dtype)
        noise = noise * strength
        # –¥—É–±–ª–∏—Ä—É–µ–º –≤ C –∫–∞–Ω–∞–ª–æ–≤
        noise = noise.expand(-1, C, -1, -1)
        return img + noise

    def chromatic_aberration(self, img, shift):
        """
        –°–¥–≤–∏–≥–∞–µ–º R/G/B –ø–æ-—Ä–∞–∑–Ω–æ–º—É
        img: [B,3,H,W]
        shift: int
        """
        B, C, H, W = img.shape
        # –ù–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π –ø—Ä–æ–≤–µ—Ä–∏–º, —á—Ç–æ–±—ã C>=3
        if C < 3:
            return img

        r = torch.roll(img[:, 0:1, :, :], shifts= shift,    dims=3)  # –≤–ø—Ä–∞–≤–æ
        g = torch.roll(img[:, 1:2, :, :], shifts= shift//2, dims=2)  # –≤–Ω–∏–∑
        b = torch.roll(img[:, 2:3, :, :], shifts=-shift,    dims=3)  # –≤–ª–µ–≤–æ
        return torch.cat([r, g, b], dim=1)

    def fade_image(self, img, fade_strength):
        """
        –°–º–µ—Å—å –∏—Å—Ö–æ–¥–Ω–∏–∫–∞ —Å –µ–≥–æ grayscale
        fade_strength=1 => –ø–æ–ª–Ω–æ—Å—Ç—å—é —Å–µ—Ä–æ–µ
        """
        gray = img.mean(dim=1, keepdim=True)  # [B,1,H,W]
        return img*(1.0 - fade_strength) + gray*fade_strength

    def add_vignette(self, img, vignette_strength):
        """
        –ü—Ä–æ—Å—Ç–µ–π—à–∞—è –≤–∏–Ω—å–µ—Ç–∫–∞: —É–º–Ω–æ–∂–∞–µ–º –ø–∏–∫—Å–µ–ª–∏ –±–ª–∏–∂–µ –∫ –∫—Ä–∞—è–º –Ω–∞ (1 - factor).
        factor ~ —Ä–∞—Å—Ç—ë—Ç –æ—Ç 0 –≤ —Ü–µ–Ω—Ç—Ä–µ –¥–æ vignette_strength –ø–æ –∫—Ä–∞—é.
        """
        B, C, H, W = img.shape
        # –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã x,y –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ [-1..1]
        yy = torch.linspace(-1, 1, steps=H, device=img.device)
        xx = torch.linspace(-1, 1, steps=W, device=img.device)
        grid_y, grid_x = torch.meshgrid(yy, xx, indexing='ij')  # [H,W]

        # —Ä–∞–¥–∏–∞–ª—å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç —Ü–µ–Ω—Ç—Ä–∞ (0,0) –¥–æ (x,y)
        rr = torch.sqrt(grid_x*grid_x + grid_y*grid_y)  # [H,W], 0..sqrt(2)
        # –Ω–æ—Ä–º–∏—Ä—É–µ–º –∫ 1.0 = –∫—Ä–∞–π
        # max_dist ~ sqrt(2) => –¥–µ–ª–∞–µ–º rr_n = rr / sqrt(2)
        rr_n = rr / math.sqrt(2)

        # factor = rr_n, –Ω–æ –º–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º –Ω–∞ vignette_strength
        factor = rr_n * vignette_strength
        # clip to [0,1]
        factor = factor.clamp(0.0, 1.0)

        # factor —Å–µ–π—á–∞—Å [H,W]. –†–∞—Å—à–∏—Ä–∏–º –¥–æ [B,1,H,W]
        factor = factor.unsqueeze(0).unsqueeze(1).expand(B, 1, H, W)

        # –∑–∞—Ç–µ–º —É–º–Ω–æ–∂–∏–º: out = img * (1 - factor)
        out = img * (1.0 - factor)
        return out

    def add_fog(self, img, fog_strength, fog_color):
        """
        –õ–∏–Ω–µ–π–Ω–æ —Å–º–µ—à–∏–≤–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å –Ω–µ–∫–∏–º —Ü–≤–µ—Ç–æ–º (fog_color).
        fog_color ‚Äî grayscale [0..1]
        fog_strength ‚Äî –¥–æ–ª—è fog_color
        """
        B, C, H, W = img.shape
        # fog_color => [C], –¥–æ–ø—É—Å—Ç–∏–º C=3, –Ω–æ –µ—Å–ª–∏ C>3, –ø—Ä–æ—Å—Ç–æ –≤–æ–∑—å–º—ë–º –ø–µ—Ä–≤—ã–µ –∫–∞–Ω–∞–ª—ã
        # –î–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã —Å—á–∏—Ç–∞–µ–º, —á—Ç–æ C=3 –∏–ª–∏ 1.  
        # –ú—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º –æ–¥–∏–Ω float => –¥–µ–ª–∞–µ–º —Å–µ—Ä—ã–π –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–∞–Ω–∞–ª–∞
        color_tensor = img.new_ones(C) * fog_color  # shape [C]
        # –∑–∞—Ç–µ–º –ø—Ä–µ–≤—Ä–∞—â–∞–µ–º [C] => [1,C,1,1], —á—Ç–æ–±—ã broadcast'–∏—Ç—å
        color_tensor = color_tensor.view(1, C, 1, 1)

        out = img*(1.0 - fog_strength) + color_tensor*(fog_strength)
        return out

    def add_vhs_effect(self, img, vhs_strength):
        """
        1) ¬´–†–∞–∑–±–∏–≤–∞–µ–º¬ª –∫–∞–∂–¥—É—é —Å—Ç—Ä–æ–∫—É —Å–ª—É—á–∞–π–Ω—ã–º —Å–¥–≤–∏–≥–æ–º.
        2) –î–æ–±–∞–≤–ª—è–µ–º ¬´scan lines¬ª (—Ç—ë–º–Ω—ã–µ –ø–æ–ª–æ—Å—ã).
        vhs_strength: 0..1
        """
        B, C, H, W = img.shape

        # –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π –ø–∏–∫—Å–µ–ª—å–Ω—ã–π —Å–¥–≤–∏–≥
        max_shift = int(5 * vhs_strength)

        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –¥–ª—è –∫–∞–∂–¥–æ–π —Å—Ç—Ä–æ–∫–∏ —Å–ª—É—á–∞–π–Ω—ã–π —Å–¥–≤–∏–≥
        # shape [H], –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ [-max_shift..+max_shift]
        if max_shift > 0:
            shifts = torch.randint(low=-max_shift, high=max_shift+1, size=(H,), device=img.device)
        else:
            shifts = torch.zeros(H, device=img.device, dtype=torch.int)

        # –ü—Ä–∏–º–µ–Ω—è–µ–º —Å—Ç—Ä–æ—á–Ω—ã–π —Å–¥–≤–∏–≥. 
        # –ü—Ä–æ—Å—Ç–µ–π—à–∏–π —Å–ø–æ—Å–æ–± ‚Äî —Ü–∏–∫–ª–æ–º –ø–æ —Å—Ç—Ä–æ–∫–∞–º (–Ω–µ –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ, –Ω–æ –Ω–∞–≥–ª—è–¥–Ω–æ).
        out = img.clone()
        for row_idx in range(H):
            shift_val = int(shifts[row_idx].item())
            if shift_val != 0:
                # —Å–¥–≤–∏–≥–∞–µ–º (roll) —Å—Ç—Ä–æ–∫—É row_idx –≤–¥–æ–ª—å —à–∏—Ä–∏–Ω—ã (dim=3)
                out[:, :, row_idx, :] = torch.roll(out[:, :, row_idx, :], shifts=shift_val, dims=2)

        # –î–æ–±–∞–≤–∏–º ¬´scan lines¬ª ‚Äî –∫–∞–∂–¥—ã–π 2-–π (–∏–ª–∏ 3-–π) —Ä—è–¥ —Ç–µ–º–Ω–µ–µ
        # intensity = 0.95..0.90, –∑–∞–≤–∏—Å—è—â–∞—è –æ—Ç vhs_strength
        line_dark = 1.0 - 0.15*vhs_strength  # ~0.85..1.0
        # –î–æ–ø—É—Å—Ç–∏–º, –∑–∞—Ç–µ–º–Ω—è–µ–º —á—ë—Ç–Ω—ã–µ —Å—Ç—Ä–æ–∫–∏
        out[:, :, 0::2, :] *= line_dark

        return out

    def add_random_glitches(self, img, glitch_strength):
        """
        Strong glitch strips with displaced blocks, color tears and noise.
        glitch_strength ~ [0..1]
        """
        if glitch_strength <= 0.0:
            return img

        B, C, H, W = img.shape
        out = img.clone()
        device = img.device

        num_blocks = max(1, int(3 + glitch_strength * 12))
        max_shift_x = max(1, int(W * (0.05 + 0.25 * glitch_strength)))
        max_shift_y = max(0, int(H * (0.02 + 0.12 * glitch_strength)))
        noise_amp = 0.3 * glitch_strength

        for b in range(B):
            for _ in range(num_blocks):
                full_width = torch.rand(1, device=device).item() < (0.25 + 0.45 * glitch_strength)
                full_height = torch.rand(1, device=device).item() < (0.15 + 0.35 * glitch_strength)

                if full_width:
                    block_w = W
                else:
                    min_frac_w = 0.05 + 0.05 * glitch_strength
                    max_frac_w = min(0.6, 0.18 + 0.5 * glitch_strength)
                    width_frac = min_frac_w + (max_frac_w - min_frac_w) * torch.rand(1, device=device).item()
                    block_w = max(8, int(W * width_frac))
                    block_w = min(block_w, W)

                if full_height:
                    block_h = H
                else:
                    min_frac_h = 0.04 + 0.04 * glitch_strength
                    max_frac_h = min(0.4, 0.12 + 0.35 * glitch_strength)
                    height_frac = min_frac_h + (max_frac_h - min_frac_h) * torch.rand(1, device=device).item()
                    block_h = max(6, int(H * height_frac))
                    block_h = min(block_h, H)

                if block_w == W:
                    x0 = 0
                else:
                    x0 = int(torch.randint(0, max(W - block_w, 1), (1,), device=device).item())
                if block_h == H:
                    y0 = 0
                else:
                    y0 = int(torch.randint(0, max(H - block_h, 1), (1,), device=device).item())

                y1 = y0 + block_h
                x1 = x0 + block_w

                block = out[b:b+1, :, y0:y1, x0:x1].clone()

                shift_x = int(torch.randint(-max_shift_x, max_shift_x + 1, (1,), device=device).item()) if max_shift_x > 0 else 0
                shift_y = int(torch.randint(-max_shift_y, max_shift_y + 1, (1,), device=device).item()) if max_shift_y > 0 else 0

                if shift_y != 0:
                    block = torch.roll(block, shifts=shift_y, dims=2)
                if shift_x != 0:
                    block = torch.roll(block, shifts=shift_x, dims=3)

                if C >= 3 and torch.rand(1, device=device).item() < 0.6 * glitch_strength:
                    channel_shift = int(torch.randint(-max_shift_x, max_shift_x + 1, (1,), device=device).item())
                    channel_idx = int(torch.randint(0, min(C, 3), (1,), device=device).item())
                    block[:, channel_idx:channel_idx+1, :, :] = torch.roll(
                        block[:, channel_idx:channel_idx+1, :, :],
                        shifts=channel_shift,
                        dims=3
                    )

                if noise_amp > 0 and torch.rand(1, device=device).item() < 0.8 * glitch_strength:
                    noise = (torch.rand_like(block) - 0.5) * noise_amp
                    block = block + noise

                if block.size(2) > 1 and torch.rand(1, device=device).item() < (0.35 + 0.4 * glitch_strength):
                    tear_row = int(torch.randint(0, block.size(2) - 1, (1,), device=device).item())
                    block[:, :, tear_row:, :] = block[:, :, tear_row:tear_row+1, :]

                block = block.clamp(0.0, 1.0)
                out[b:b+1, :, y0:y1, x0:x1] = block

        return out
